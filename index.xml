<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>破耳狼</title>
    <link>http://moketao.gitcafe.io/</link>
    <description>Recent content on 破耳狼</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 19 Apr 2015 16:13:06 +0800</lastBuildDate>
    <atom:link href="http://moketao.gitcafe.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>TextureGod ，“窥视”显卡内部的贴图和滤镜</title>
      <link>http://moketao.gitcafe.io/texture_god/</link>
      <pubDate>Sun, 19 Apr 2015 16:13:06 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/texture_god/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://moketao.gitcafe.io/img/tg.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;有段时间，我对于 Adobe scout 非常不满，并且对项目频频闪退，也很恼火。&lt;/p&gt;

&lt;p&gt;于是。。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TextureGod&lt;/strong&gt; 诞生了。&lt;/p&gt;

&lt;p&gt;用来 “监控” Starling 和 FeathersUI 的贴图，“窥视”显卡内部的贴图、滤镜。&lt;/p&gt;

&lt;p&gt;如果想知道某张贴图或者滤镜，是否被多次 new 出来浪费了显存，&lt;/p&gt;

&lt;p&gt;只要打开 TextureGod 就能一目了然。&lt;/p&gt;

&lt;p&gt;其实用 TextureGod 来取名，确实有点托大，不过，当时没时间多想，急着解决问题。
所以就取了这样一个名字。&lt;/p&gt;

&lt;p&gt;说起来原理非常简单：&lt;/p&gt;

&lt;p&gt;TextureGod 并不是真的能读取显卡的显存，而是通过socket连接游戏，监控贴图上传显卡和销毁贴图的过程，主要是通过修改 Starling 的 Texture 这个类。&lt;/p&gt;

&lt;p&gt;修改的地方如下：&lt;/p&gt;

&lt;pre&gt;
starling.textures.Texture
    fromAtfData 方法中的参数 async，声明的类型从Function修改为通配类型
    async:Function -&gt; async:*

Texture
    添加如下三个属性：
        public var name:String;//fix
        public static var hasGodSon:Boolean;//这个值在 TextureGodSon 的构造函数中设置//fix
        public static var TextureGodSonClass:*;//fix
    构造函数里加入：
        if(hasGodSon)name = Math.random()+&#34;&#34;;//fix
    
    在 fromBitmapData 函数中加入：
        if(hasGodSon)TextureGodSonClass.add(texture.name,data);//fix
    
    在 fromAtfData 函数中加入：
        if(hasGodSon)TextureGodSonClass.add(concreteTexture.name,data);//fix
    
    在 dispose 函数中加入：
        if(hasGodSon)TextureGodSonClass.remove(name);//子类会通过super.dispose调用到此处//fix
    
ColorMatrixFilter
    构造函数前三行，改为：
        public function ColorMatrixFilter(matrix:Vector.&lt;Number&gt;=null,name:String=&#34;&#34;)//fix
        {
            super(1,1.0,name);
            if(name==&#34;&#34;||name==null) throw new Error(&#34;使用滤镜请加名字，便于排查问题&#34;);//fix
        
FragmentFilter
    添加两个属性：
            public var name:String;//fix
            public var hasDispose:Boolean;//fix
    构造函数加上：
        public function FragmentFilter(numPasses:int=1, resolution:Number=1.0,name:String=&#34;&#34;)//fix
        {
            if(Texture.hasGodSon){//fix
                this.name = name+Math.random();//fix
                if(name==&#34;&#34; || name==null) this.name = &#34;filter_&#34;+Math.random();//fix
                Texture.TextureGodSonClass.add(this.name);//fix
            }//fix
    dispose 函数中加入：
            if(Texture.hasGodSon) Texture.TextureGodSonClass.remove(name);//fix
            hasDispose = true;//fix


&lt;/pre&gt;

&lt;p&gt;说到底就一句话：&lt;/p&gt;

&lt;p&gt;贴图产生的时候，给贴图取个名，然后把bitmap存到字典里。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BuildingAssetBundles in 5.x 中文简译</title>
      <link>http://moketao.gitcafe.io/building_asset_bundles_in_5_cn/</link>
      <pubDate>Thu, 16 Apr 2015 18:14:20 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/building_asset_bundles_in_5_cn/</guid>
      <description>

&lt;p&gt;每篇博文的诞生，都是因为世界不够完美。&lt;/p&gt;

&lt;p&gt;这不，Unity5刚出来，打包流程和之前差别较大，国内搜到的都是关于4.6的文章。&lt;/p&gt;

&lt;p&gt;言归正传，以下简单翻译，英文原文在 &lt;a href=&#34;http://docs.unity3d.com/Manual/BuildingAssetBundles5x.html&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;AssetBundles说白了就是一种的压缩包，挂着服务器上让玩家下载更新游戏资源。&lt;/p&gt;

&lt;p&gt;Unity 4.x 的环境里，都是用脚本去创建 AssetBundles （以下简称&lt;strong&gt;AB&lt;/strong&gt;）。
Unity5.x为了简化流程，添加了可视化工具。当你选择某个资源的时候，比如一张图片，你会发现在屏幕右下角，多了两个关于AssetBundles的下拉菜单。在第一个菜单里，你可以新建一个&lt;strong&gt;AB&lt;/strong&gt;，或者将当前资源归到某个你已经建好的&lt;strong&gt;AB&lt;/strong&gt;里。第二个下拉菜单是指定变体的，默认是没有变体的，但你可以新建。比如sd变体（标清版）和hd变体（高清版），具体说：&lt;/p&gt;

&lt;p&gt;你可以仅仅指定一个名为foo的&lt;strong&gt;AB&lt;/strong&gt;。这样就没有变体一说，整个世界很干净。可是，如果你新建了一个foo的&lt;strong&gt;AB&lt;/strong&gt;，又给这个&lt;strong&gt;AB&lt;/strong&gt;新增了两个变体，sd和hd，那么，将来导出资源包的时候，就不是foo这个包，而是foo.sd和foo.hd两个包。世界变得很脏，但随之而来的好处是，你可以在某些情况下，切换标清和高清画质。&lt;/p&gt;

&lt;h1 id=&#34;ab导出:efc30dcb7244a334a10687b605945d4b&#34;&gt;AB导出&lt;/h1&gt;

&lt;p&gt;说的有点抽象，接下来实验一下就清楚了，先复制如下代码：&lt;/p&gt;

&lt;pre&gt;
using UnityEditor;
using UnityEngine;
public class CreateAssetBundles
{
    [MenuItem (&#34;Assets/★Build AssetBundles&#34;)]
    static void BuildAllAssetBundles ()
    {
        BuildPipeline.BuildAssetBundles (&#34;c:/abs&#34;,BuildAssetBundleOptions.UncompressedAssetBundle);
    }
}
//使用BuildAssetBundleOptions.UncompressedAssetBundle这个参数，是为了不压缩，
//否则后面用 AssetBundle.CreateFromFile 读取会报错，AssetBundle.CreateFromFile 不支持压缩格式。
//当然，用 WWW.LoadFromCacheOrDownload 这个函数，是支持压缩格式的。
//只是程序写法上，比较蛋疼这个后面会讲到。
&lt;/pre&gt;

&lt;p&gt;然后：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在c盘建立一个名为 abs 的目录，当然，名字是随意的。&lt;/li&gt;
&lt;li&gt;在Assets目录下新建一个Plugin目录。&lt;/li&gt;
&lt;li&gt;在Plugin目录下创建一个名字叫做 CreateAssetBundles 的脚本。&lt;/li&gt;
&lt;li&gt;把上面那段代码粘贴到 CreateAssetBundles里面。&lt;/li&gt;
&lt;li&gt;随便选择一张贴图，将它分配到一个&lt;strong&gt;AB&lt;/strong&gt;里，没有就新建一个&lt;strong&gt;AB&lt;/strong&gt;，是否新建变体，新建多少个变体，就随便你了。&lt;/li&gt;
&lt;li&gt;在Unity的 Assets 菜单里，你会看见我们刚刚创建的“★Build AssetBundles”菜单，点它，然后去 c:/abs 看看有没有生成什么东西。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面那段代码也可以改成这样：
&lt;pre&gt;
using UnityEditor;
using UnityEngine;
public class CreateAssetBundles
{
    [MenuItem (&amp;ldquo;Assets/★Build AssetBundles&amp;rdquo;)]
    static void BuildAllAssetBundles ()
    {
        BuildPipeline.BuildAssetBundles (Application.streamingAssetsPath+ &amp;ldquo;/AssetBundles&amp;rdquo;,BuildAssetBundleOptions.UncompressedAssetBundle);
    }
}
//需要注意的是：Assets目录下必须存在 StreamingAssets 目录，
//并且StreamingAssets目录下必须存在 AssetBundles目录，没有就手动新建。
&lt;/pre&gt;&lt;/p&gt;

&lt;h1 id=&#34;ab加载:efc30dcb7244a334a10687b605945d4b&#34;&gt;AB加载&lt;/h1&gt;

&lt;p&gt;写到一半，刚搜到另外一位达人写的心得，直接转了：
点&lt;a href=&#34;http://liweizhaolili.blog.163.com/blog/static/162307442015282017852/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unity3D常用路径解读（表格版本）</title>
      <link>http://moketao.gitcafe.io/unity_path_ios_android/</link>
      <pubDate>Tue, 14 Apr 2015 14:26:54 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/unity_path_ios_android/</guid>
      <description>

&lt;p&gt;关于Unity的资源路径和权限，网上的资料都很零散，于是我打算用表格来解释清楚。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Unity目录&lt;/th&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;iTunes备份（ios）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Application.&lt;strong&gt;dataPath&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;只读&lt;/strong&gt; ，打包时内容已固定，不能更改，可以读取“sceneName.unity3d”(待验证)&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Application.&lt;strong&gt;streamingAssetsPath&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;只读&lt;/strong&gt; ，打包时内容已固定，不能更改，程序员在Unity项目的Assets文件夹下手动创建的&amp;rdquo;StreamingAssets&amp;rdquo;目录，可以存放xml、json、jpg、mp4等等文件，手机平台上只读，台式机可以读写。&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Application.&lt;strong&gt;persistentDataPath&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;可读可写&lt;/strong&gt;，用户使用过程中产生的数据，比如分享截图、下载音乐等等。此目录暴露给用户，用户打开iTunes就看得见，当然此目录也可以存放app生成的文件或下载文件。此目录会被备份到iTunes并同步到其它苹果设备（如果用户有多台iPhone的话），但是app审核上线期间不要在这个目录占用太多，否则有可能会通不过审核，如果更新包很大的话，推荐使用Application.&lt;strong&gt;temporaryCachePath&lt;/strong&gt; 存放下载更新包。&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Application.&lt;strong&gt;temporaryCachePath&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;可读可写&lt;/strong&gt;，不会被iTunes备份，但也不会被删除，会一直保留在当前设备。&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;关于ios的目录权限，可进一步参考 &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html&#34;&gt;这里&lt;/a&gt; 和 &lt;a href=&#34;https://developer.apple.com/icloud/documentation/data-storage/index.html&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;streamingAssetsPath下的文件读取方法是：
&lt;pre&gt;&lt;code&gt;#if UNITY_EDITOR
    string filepath = Application.dataPath +&amp;ldquo;/StreamingAssets&amp;rdquo;+&amp;ldquo;/my.xml&amp;rdquo;;
#elif UNITY_IPHONE
    string filepath = Application.dataPath +&amp;ldquo;/Raw&amp;rdquo;+&amp;ldquo;/my.xml&amp;rdquo;;
#elif UNITY_ANDROID
    string filepath = &amp;ldquo;jar:file://&amp;rdquo; + Application.dataPath + &amp;ldquo;!/assets/&amp;rdquo;+&amp;ldquo;/my.xml;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;h3 id=&#34;ios:16683e76e14a70877b630ac3dd20e29c&#34;&gt;IOS:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Application.dataPath :             Application/xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data
Application.streamingAssetsPath :  Application/xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/Raw
Application.persistentDataPath :   Application/xxxx-xxxx-xxxxxxxxxxxx/Documents
Application.temporaryCachePath :   Application/xxxx-xxxx-xxxxxxxxxxxx/Library/Caches&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;android:16683e76e14a70877b630ac3dd20e29c&#34;&gt;Android:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Application.dataPath :                /data/app/xxx.xxx.xxx.apk
Application.streamingAssetsPath :     jar:file:///data/app/xxx.xxx.xxx.apk/!/assets
Application.persistentDataPath :      /data/data/xxx.xxx.xxx/files
Application.temporaryCachePath :      /data/data/xxx.xxx.xxx/cache&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;windows:16683e76e14a70877b630ac3dd20e29c&#34;&gt;Windows:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Application.dataPath :                /Assets
Application.streamingAssetsPath :     /Assets/StreamingAssets
Application.persistentDataPath :      C:/Users/xxxx/AppData/LocalLow/CompanyName/ProductName
Application.temporaryCachePath :      C:/Users/xxxx/AppData/Local/Temp/CompanyName/ProductName&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mac:16683e76e14a70877b630ac3dd20e29c&#34;&gt;Mac:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Application.dataPath :                /Assets
Application.streamingAssetsPath :     /Assets/StreamingAssets
Application.persistentDataPath :      /Users/xxxx/Library/Caches/CompanyName/Product Name
Application.temporaryCachePath :      /var/folders/57/6b4_9w8113x2fsmzx_yhrhvh0000gn/T/CompanyName/Product Name&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>最近做的妹子</title>
      <link>http://moketao.gitcafe.io/3dgirl/</link>
      <pubDate>Wed, 08 Apr 2015 11:53:21 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/3dgirl/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://moketao.gitcafe.io/img/idle08.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;整体风格，我尽量做的偏东方女性的风格。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>行为树（决策树）AI编辑器</title>
      <link>http://moketao.gitcafe.io/ai_behavior_editor/</link>
      <pubDate>Wed, 01 Apr 2015 17:58:08 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/ai_behavior_editor/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://moketao.gitcafe.io/img/ai.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;关于我实现的那个AI编辑器，以前有提到过，写在csdn的blog上。
可以点&lt;strong&gt;&lt;a href=&#34;http://blog.csdn.net/mokt2001/article/details/23034309&#34;&gt;这里&lt;/a&gt;&lt;/strong&gt;查看。&lt;/p&gt;

&lt;p&gt;这里补充一下演示视频：&lt;/p&gt;

&lt;video src=&#34;http://121.40.174.8/ai2.mp4&#34; width=&#34;720&#34; height=&#34;486&#34; controls=&#34;controls&#34;&gt;
您的浏览器不支持 HTML5 的视频功能
&lt;/video&gt;

&lt;p&gt;&lt;a href=&#34;http://121.40.174.8/ai2.mp4&#34;&gt;ai2.mp4&lt;/a&gt;&lt;/p&gt;

&lt;video src=&#34;http://121.40.174.8/ai1.mp4&#34; preload=&#34;false&#34; width=&#34;720&#34; height=&#34;486&#34; controls=&#34;controls&#34;&gt;
您的浏览器不支持 HTML5 的视频功能
&lt;/video&gt;

&lt;p&gt;&lt;a href=&#34;http://121.40.174.8/ai1.mp4&#34;&gt;ai1.mp4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;视频里面所呈现的节点，会闪烁。
闪烁代表当前逻辑执行到的地方。
我实现了一个时间加倍滑块，视频里看到的闪烁速度相对较慢。
真实游戏里，可以根据需求，加快运算速度。
即便是一帧运行一个节点，性能消耗也微乎其微。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于UI编辑器的一些实践和思考</title>
      <link>http://moketao.gitcafe.io/ui_thinking/</link>
      <pubDate>Wed, 25 Mar 2015 16:46:25 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/ui_thinking/</guid>
      <description>&lt;p&gt;经历了3个项目，都是前端程序员写死的UI，没有编辑器的概念，全是程序员写死的UI布局，企业都没有想到这方面的传承，也很少有主程序会去关注UI编辑器，或者是我遇到的主程还不够多？&lt;/p&gt;

&lt;p&gt;后来忍不住写了一个叫做 XLayout 的 UI编辑器，基于 Starling 和 FeathersUI 的百分比布局模式，导出成 xml 或者 json，通过配置加载和读取，在游戏中“反射”回来。&lt;/p&gt;

&lt;p&gt;只有UI编辑器实现了，并且成熟了，前端才不需要那么多程序员，或者说前端程序员可以多用点时间在别的事情上，而不是整天跟那堆UI代码死磕。&lt;/p&gt;

&lt;p&gt;当然了，Flex4.6 也早就实现了类似的功能，可惜现在连 FlashBuilder 4.7 都不再维护了。&lt;/p&gt;

&lt;p&gt;下面是几张 XLayout 的截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://moketao.gitcafe.io/img/u00.png&#34; alt=&#34;&#34; /&gt;

↑对于属性编辑面板，我自己还是比较满意的。只要某控件实现了指定的接口，就可以在属性面板上显示它想要呈现给编辑者的任意多个属性，并支持下拉选项，数值，字符串等类型。另外还支持了拖拽 Label区域来改变数值的功能，以及颜色拾取器、图片拾取的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://moketao.gitcafe.io/img/u01.png&#34; alt=&#34;&#34; /&gt;

↑而对于百分比布局面板，就不太满意了，主要是因为这几天，我试用了Unity迟来的、新的GUI系统（简称 &lt;strong&gt;UGUI&lt;/strong&gt;），才有这样的感觉的。下面是 &lt;strong&gt;UGUI&lt;/strong&gt; 的截图，我感觉下面这个布局面板(Rect transform)，是 &lt;strong&gt;UGUI&lt;/strong&gt; 最有价值的功能，没有之一，这个面板集合了绝对定位和相对定位的概念在里面，用了就回不去了↓：
&lt;img src=&#34;http://moketao.gitcafe.io/img/u02.png&#34; alt=&#34;&#34; /&gt;

↑当然， &lt;strong&gt;UGUI&lt;/strong&gt;，并没有NGUI那么多功能，稍微有点欠缺。但是有 Rect transform 布局已经很爽了，我将来写的编辑器，百分百会剽窃这个概念。 我太坏了，先跟Unity道个歉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://moketao.gitcafe.io/img/u03.png&#34; alt=&#34;&#34; /&gt;

↑这张图，是我对未来全新UI编辑器的展望，策划只要使用特殊账号进入游戏，就能够编辑界面，包括移动按钮位置，修改面板背景，添加 lua 脚本或者其它可视化编程脚本等等（类似于虚幻4的蓝图系统）。&lt;/p&gt;

&lt;p&gt;另外，最好是 XLayout 能够导出ui给多个引擎和项目组使用，那是最理想的状态。
当然重口难调也是难免的。。。那就把UI编辑器拆分成轻量级的类库，让每个项目独立、快速的定制自己的UI编辑器，这或许也不错。&lt;/p&gt;

&lt;p&gt;呵呵，也只是想想，不一定能实现。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>游戏公告编辑器（html）</title>
      <link>http://moketao.gitcafe.io/htmleditor_for_game/</link>
      <pubDate>Sat, 21 Mar 2015 16:13:28 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/htmleditor_for_game/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://moketao.gitcafe.io/img/ge.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://moketao.gitcafe.io/data/FlashHtmlEditor2.rar&#34;&gt;FlashHtmlEditor2.rar&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UnityVS 安装与使用</title>
      <link>http://moketao.gitcafe.io/unityvs_install/</link>
      <pubDate>Mon, 16 Mar 2015 17:24:02 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/unityvs_install/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;先安装 &lt;strong&gt;VS2013&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;然后再安装 &lt;strong&gt;UnityVS&lt;/strong&gt; ，UnityVS在2014年被微软收购，所以现在是免费的，感谢微软。VS2013对应UnityVS 2013，从&lt;a href=&#34;https://visualstudiogallery.msdn.microsoft.com/20b80b8c-659b-45ef-96c1-437828fe7cf2&#34;&gt;这里&lt;/a&gt;下载，下载页面可以选择其他版本的UnityVS，比如2015版本的。&lt;/li&gt;
&lt;li&gt;进入Unity，导入UnityVS包。&lt;/li&gt;
&lt;li&gt;检查看一下Unity的菜单：Edit &amp;gt;&amp;gt; Preferences &amp;gt;&amp;gt; External Script Editor 。 当前选项应该变成了 UnityVS.OpenFile，如果没有就手动选择一下。&lt;/li&gt;
&lt;li&gt;这个时候再去新建 C# ，双击即可打开VS2013.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>使用 Unity Shader 实现 GPU Hair</title>
      <link>http://moketao.gitcafe.io/unity_shader_gpu_hair/</link>
      <pubDate>Fri, 13 Feb 2015 09:39:39 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/unity_shader_gpu_hair/</guid>
      <description>&lt;p&gt;本来想用 &lt;strong&gt;Unity&lt;/strong&gt; &lt;strong&gt;布料系统&lt;/strong&gt; 实现头发或飘带等效果，但是使用过后，发现非常消耗性能。
所以不得不研究别的办法。
下面是我的实现方法，&lt;strong&gt;GPU Hair&lt;/strong&gt;：
&lt;img src=&#34;http://moketao.gitcafe.io/img/gpuhair.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;pre&gt;
Shader &#34;Custom/GPUHair&#34;{
    Properties{
        _MainTex (&#34;Base (RGB)&#34;, 2D) = &#34;white&#34; {}        //贴图
        _DelayPoint (&#34;DelayPoint&#34;, Vector) = (9.0,0,0,0)//尾部位置
        _HairLength(&#34;HairLength&#34;,Float) = 5             //头发长度
        _TimeScale(&#34;TimeScale&#34;,Range(0.0,200)) = 50     //波形速度
    }
    SubShader{
        Tags{&#34;RenderType&#34;=&#34;Opaque&#34;}
        Cull off
        CGPROGRAM
        #pragma surface SurfFun Lambert vertex:VertFun
        sampler2D _MainTex;

        float _TimeScale;
        float4 _DelayPoint;
        float _HairLength;

        void VertFun(inout appdata_full v){
            _DelayPoint.w = 1;//修正头发变形的bug
            float4 localPos = mul(_World2Object,_DelayPoint);//把尾部的坐标，从世界坐标系挪移进头发模型中
            float factor = clamp(v.vertex.x/_HairLength,0,1);//当前点在发根到发梢的哪个位置（0~1.0）
            float tmpZ = v.vertex.z;//记录z
            v.vertex.z = 0;//把当前点先暂时挪到中间
            float4 dis = pow(factor,2)*(localPos - v.vertex);//当前点到尾部的距离
            v.vertex.y += factor*2*cos(v.vertex.x - _Time*_TimeScale);//波形
            v.vertex = v.vertex + dis;//波形加上甩尾偏移（当人物或者发根移动的时候）
            v.vertex.z += tmpZ;//恢复之前记录的z
        }

        struct Input{
            float2 uv_MainTex;
        };
        void SurfFun(Input IN, inout SurfaceOutput o){
            half4 c = tex2D (_MainTex, IN.uv_MainTex);
            o.Albedo = c.rgb;
            o.Alpha = c.a;
        }
        ENDCG
    }
    Fallback &#34;Diffuse&#34;
}
&lt;/pre&gt;

&lt;p&gt;另外，场景里对应的网格物体，需要再挂一个脚本：&lt;/p&gt;

&lt;pre&gt;
using UnityEngine;
using System.Collections;

public class DelayPoint : MonoBehaviour {

    public GameObject delayPoint;//尾部
    public float delayTime = 0.5f;

    private Transform t1;//网格物体中心点所在位置（发根）
    private Transform t2;//尾部所在位置（发梢）
    private Vector3 distanceToT1;//尾部到中心的距离

    private Vector3 velocity = Vector3.zero;//当前速度
    private Vector3 targetPoint = Vector3.zero;//跟随点

    void Start () {
        t1 = transform;
        t2 = delayPoint.transform;
        distanceToT1 = t2.position - t1.position;
    }
    
    void Update () {
        targetPoint = t1.position + distanceToT1;
        Vector3 newPos = Vector3.SmoothDamp(t2.position, targetPoint, ref velocity, delayTime);//尾部的缓动效果
        t2.position = newPos;
        Renderer render = t1.GetComponent&lt;Renderer&gt;();
        render.material.SetVector(&#34;_DelayPoint&#34;, t2.position);//将尾部的坐标传送给显卡
    }
}
&lt;/pre&gt;

&lt;p&gt;具体使用方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;建立一个plane，大小默认（边长是10），或者用3dsmax建模。&lt;/li&gt;
&lt;li&gt;给plane加上脚本和材质，材质的Shader指定为 Custom/GPUHair。&lt;/li&gt;
&lt;li&gt;建立一个空物体，放置到plane边缘，大概是（5,0,0）的位置。&lt;/li&gt;
&lt;li&gt;在脚本上你会看见一个delayPoint的属性，把空物体拖拽到这个属性上。&lt;/li&gt;
&lt;li&gt;点击播放按钮。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;项目源码下载（Unity5导出，4.x版本不知道能不能打开）：
&lt;a href=&#34;http://moketao.gitcafe.io/data/GPUHair.rar&#34;&gt;GPUHair.rar&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果要像虚幻引擎那样支持碰撞检测，应该也没问题，加入圆和半径的计算就可以了。
当然，参与计算的圆越少越好，手游甚至可以不考虑碰撞。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>dxsdk 安装过程中报错: S1023</title>
      <link>http://moketao.gitcafe.io/dxsdk_install_err/</link>
      <pubDate>Tue, 13 Jan 2015 17:47:19 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/dxsdk_install_err/</guid>
      <description>

&lt;p&gt;安装directx sdk 报错： errors were encountered during installation of redistributable package s1023&lt;/p&gt;

&lt;h3 id=&#34;解决步奏:31e555ba754a60275651e451df32011c&#34;&gt;解决步奏:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;点击系统的【开始】按钮，然后点【运行】&lt;/li&gt;
&lt;li&gt;输入&lt;strong&gt;cmd&lt;/strong&gt;，回车&lt;/li&gt;
&lt;li&gt;分别粘贴如下命令，回车（目的是卸载某些冲突的组件）
&lt;pre&gt;&lt;code&gt;MsiExec.exe /passive /X{F0C3E5D1-1ADE-321E-8167-68EF0DE699A5}
MsiExec.exe /passive /X{1D8E6291-B0D5-35EC-8441-6616F567A0F7}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;重新安装 dx sdk&lt;/li&gt;
&lt;li&gt;再安装刚才卸载的 &lt;a href=&#34;http://www.microsoft.com/en-us/download/details.aspx?displaylang=en&amp;amp;id=26999&#34;&gt;组件&lt;/a&gt; 如果是64位系统，最好 &lt;strong&gt;vcredist_x86.exe&lt;/strong&gt; 和 &lt;strong&gt;vcredist_x64.exe&lt;/strong&gt; 都装一次。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;英文解决方案原帖，点 &lt;a href=&#34;http://blogs.msdn.com/b/chuckw/archive/2011/12/09/known-issue-directx-sdk-june-2010-setup-and-the-s1023-error.aspx&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用sublime写shader也可以有 autocomplete（笨办法）</title>
      <link>http://moketao.gitcafe.io/sublime_autocomplete/</link>
      <pubDate>Sat, 10 Jan 2015 20:05:28 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/sublime_autocomplete/</guid>
      <description>&lt;p&gt;编写 Unity 的Shader，最痛苦的就是没有代码 &lt;strong&gt;自动完成&lt;/strong&gt; 的代码提示了，今天装了 &lt;strong&gt;Sublime Text&lt;/strong&gt;，只有高亮，于是想出一种超龊的办法，在前面粘贴一段类似的注释代码，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://moketao.gitcafe.io/img/subl_auto.png&#34; alt=&#34;sublime_unity_shader_auto_complete&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>技能编辑器</title>
      <link>http://moketao.gitcafe.io/skilleditor/</link>
      <pubDate>Fri, 19 Dec 2014 16:12:47 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/skilleditor/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://moketao.gitcafe.io/img/skilleditor.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;因为赶时间，所以并没有认真思考如何去写。&lt;/p&gt;

&lt;p&gt;如果上天再给我一次机会，我希望：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;所有模块拆开来写。尽量轻量级，所有模块可以单独使用。&lt;/li&gt;
&lt;li&gt;中间用消息模块连接。&lt;/li&gt;
&lt;li&gt;定义一系列接口。&lt;/li&gt;
&lt;li&gt;面向通用游戏引擎，不捆绑特定类型的游戏。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>蠕虫算法，一个游戏角色行走路径的解决方案</title>
      <link>http://moketao.gitcafe.io/poly_finder/</link>
      <pubDate>Thu, 20 Nov 2014 11:34:21 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/poly_finder/</guid>
      <description>&lt;p&gt;这个算法是为了优化A*算法而产生的。算是一个优化Astar。&lt;/p&gt;

&lt;p&gt;缘由是,主程说怪物行走时太消耗性能了。于是让我优化一下（因为我是负责怪物AI的）。&lt;/p&gt;

&lt;p&gt;如果是开放式地图，那么怪物AI就由后端来处理了。
不过我们这个是手游，都是单人副本比较多。所以怪物自然要具备一些智商，最基本的智商就是，从地图的A点行进到玩家所在的B点。如果只是单独一只怪物，行进时所需要计算的AStar逻辑并不多，如果错开时间，每隔两秒修正一下路径，那么运算量微乎其微，但是，如果是几十只怪物。。。运算量就大了。&lt;/p&gt;

&lt;p&gt;于是我就开始冥思苦想。&lt;/p&gt;

&lt;p&gt;终于让我想到了这个算法：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;蠕虫算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;若有雷同，纯属巧合，不胜荣幸。
下面是我的伪代码：
&lt;pre&gt;&lt;/p&gt;

&lt;p&gt;将场景分割成16*16像素的格子。红色格子是不可行走区域，其它格子是可行走区域。&lt;/p&gt;

&lt;p&gt;每隔3个格子，产生一个圆，并将其的半径慢慢扩展，直到圆碰触到红色格子。&lt;/p&gt;

&lt;p&gt;挑选出最大的那个圆。&lt;/p&gt;

&lt;p&gt;基于这个圆，生成一个向外慢慢扩展的凸多边形。&lt;/p&gt;

&lt;p&gt;当凸多边形扩展到一定程度，就不能再扩展了，因为面积已经最大化。&lt;/p&gt;

&lt;p&gt;将这个多边形的编号，赋值给多边形所包含的所有16*16像素的格子，这样格子就从属于多边形。&lt;/p&gt;

&lt;p&gt;找到所有的多边形。&lt;/p&gt;

&lt;p&gt;将多边形之间的连接点算出来。&lt;/p&gt;

&lt;p&gt;所有的连接点、所有的多边形 ，构成了一个小型的AStar网络。&lt;/p&gt;

&lt;p&gt;在这个Astar网络里，计算每一个多边形到达其它多边形的路径，并存储起来。&lt;/p&gt;

&lt;p&gt;在实际游戏中，引擎读取多边形相关的路径字典，再读取格子所属多边形。&lt;/p&gt;

&lt;p&gt;怪物行走时，只需要通过格子所属多边形进行查表，即可获得路径。&lt;/p&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这个算法的优点是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;全部查表，不消耗 CPU，不运算AStar。&lt;/li&gt;
&lt;li&gt;暂时没想到。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缺点是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;每个地图的预运算时间比较长，在5分钟到10分钟左右。&lt;/li&gt;
&lt;li&gt;地图可行走区域更新的时候，需要重新计算。&lt;/li&gt;
&lt;li&gt;以内存换速度，不过消耗的内存也不多，一个地图10KB左右。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面是演示视频：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pan.baidu.com/s/1mgAAer2&#34;&gt;http://pan.baidu.com/s/1mgAAer2&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang、cuda、Windows 开发环境搭建</title>
      <link>http://moketao.gitcafe.io/Golang_cuda_Windows/</link>
      <pubDate>Sun, 02 Nov 2014 10:51:57 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/Golang_cuda_Windows/</guid>
      <description>

&lt;h2 id=&#34;步骤:cb248cbf25583db7cd96fd4710d513a3&#34;&gt;步骤&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;因为我的系统是 Win7 64位的，所以先装&lt;strong&gt;Mingw-w64&lt;/strong&gt;，下载地址：&lt;a href=&#34;http://sourceforge.net/projects/mingw-w64/&#34;&gt;http://sourceforge.net/projects/mingw-w64/&lt;/a&gt;
安装的时候选 x86_64，其它默认&lt;/li&gt;
&lt;li&gt;然后安装&lt;strong&gt;CUDA&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后安装&lt;strong&gt;Golang&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后安装&lt;strong&gt;EveryThing&lt;/strong&gt;，这是个文件搜索软件，等下会用到&lt;/li&gt;
&lt;li&gt;打开命令窗口cmd，运行：&lt;code&gt;go get github.com/barnex/cuda5&lt;/code&gt;，报错：&lt;code&gt;cannot find -lcuda&lt;/code&gt;，网上搜出全都是Linux解决方案，让我抓狂，所以才有此文。&lt;/li&gt;
&lt;li&gt;用EveryThing搜&lt;strong&gt;cgoflags.go&lt;/strong&gt;，发现在GOPAT的某些目录下包含总共4个cgoflags.go文件，打开后，发现最后面有Windows相关配置&lt;/li&gt;
&lt;li&gt;4个cgoflags.go文件依次打开，将内部有关Windows的部分，全部改成：&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;pre&gt;
////WINDOWS:
//#cgo windows LDFLAGS:-LF:/cuda/bin/lib/x64
//#cgo windows CFLAGS: -IF:/cuda/bin/include
import &#34;C&#34;
&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;注意事项:cb248cbf25583db7cd96fd4710d513a3&#34;&gt;注意事项&lt;/h2&gt;

&lt;p&gt;上面代码中的F:/cuda/bin/lib/x64，代表cuda安装目录下的的lib目录，&lt;/p&gt;

&lt;p&gt;上面代码中的F:/cuda/bin/include，代表cuda安装目录下的的include目录。&lt;/p&gt;

&lt;p&gt;如果你的cuda安装在&lt;strong&gt;C盘&lt;/strong&gt;，则上面相应位置则是以C:/开头，而不是F:/开头。&lt;/p&gt;

&lt;p&gt;斜杠注释不要去掉，golang能读，import &amp;ldquo;C&amp;rdquo;那一行必须与上一行&lt;strong&gt;紧贴&lt;/strong&gt;，中间不能有空行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>http://moketao.gitcafe.io/about/</link>
      <pubDate>Sun, 07 Sep 2014 13:49:00 +0800</pubDate>
      
      <guid>http://moketao.gitcafe.io/about/</guid>
      <description>

&lt;h2 id=&#34;联系方式:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;联系方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;name 莫克陶&lt;/li&gt;
&lt;li&gt;email moketao@qq.com&lt;/li&gt;
&lt;li&gt;qq 30558209&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;经历:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;经历&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2011 web.4399.com&lt;/li&gt;
&lt;li&gt;2013 www.zqgame.com.cn&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>